

var javascript高级_day05 = {
	"闭包现象的产生" : [
					"在某个函数的内部, 执行了其他函数",
						" 该函数在执行的时候, 访问了上一个函数存储的值",
						" 那么在这个过程中, 就发生了闭包这个现象",
					"如果需要以这种方式做开发, 那么需要在函数A内部返回函数B ",
						" 函数B保存了由函数A传入进来的参数或者变量",
						" 将函数A调用一次, 得到返回的函数体B ",
						" 每次调用函数体B则能从闭包中取到那个局部作用域中的值 ",
					/*for (var i = 0; i < list.length; i++) {
				      var li = list[i];

				      (function (i) {
				        li.onclick = function () {
				          // 2 点击li的时候输出当前li对应的索引
				          console.log(i);
				        }
				      })(i);
				    }*/
					"这样做有什么好处? ",
						" 通过函数B的调用, 访问到了一个局部作用域中的值, 数据请求很安全不会存在冲突 ",
						" 原本应该调用结束被回收的值, 现在被悄悄拿到, 没有任何中间人来篡改或者增加东西 ",
					"还有哪些地方存在这个现象? ",
						" 当自调用函数中, 有定时器, 那么该定时器内的函数, 将会在整个js调用结束执行 ",
							" 因为js调用全局函数的过程很快, 看不出来调用定时器请求自调用函数的内容时发生了闭包 ",
						" 当自调用函数中批量注册事件, 在响应事件的时候调用函数并且请求自调用函数中的参数也发生了闭包 ",
						" 结论1: 比较简单的一种格式就是, 用过自调用函数接收参数或者计算某个值, 然后通过内部函数调用去获取 ",
					"闭包的补充 ",
						" 如果是一个对象中的方法, 结果返回了一个函数, 想知道函数中this指向了谁 ",
						" 对象调用方法, 所以方法中的this指向该对象, 但是返回了另外一个函数 ",
						" 所以对象调用方法拿到了函数, 函数调用时this却指的是window ",
						" 那么在对象调用方法的时候把this赋值给一个变量, 在调用新函数的时候, 打印变量, 就是那个对象 ",
						" 这样就能访问对象中的其他成员了 ",
					/*var name = "The Window";　　
					var object = {　　　　
					  name: "My Object",
					  getNameFunc: function () {
					    var that = this;
					    return function () {
					      return that.name;
					    };
					  }
					};
					console.log(object.getNameFunc()());*/
					],
	"定时器是如何工作的" : [
					"js是单线程的 ",
						" 就相当于所有的任务或者叫事件都由一个人来处理, 一项项解决 ",
					"当页面中出现定时器, 注册事件, 或者由ajax得到的回调函数 ",
						" 浏览器会将其置入事件队列中, 等待被执行 ",
						" 等到了触发或者调用条件, 则从Event Loop(事件环)中去找到对应的函数执行 ",
					"了解这个原理有助于解释一些页面中的现象 ",
					],
	"递归" : [
		 		   " 递归的用法就是在自身函数的内部调用了自身函数 ",
		 		   		" 需要做一些条件限制, 不然会出现死递归 ",
		 		   " 递归的高级在于, 在执行某个return的时候, 结果并不明确 ",
		 		   		" 并且还依赖自己再次调用 ",
		 		   		" 直到拿到限制条件, 然后依次代入之前的return中进行运算, 并且返回最终结果 ",
		 		   " 如果出现多次调用, 页面会卡死 ",
		 		   		" 就像斐波那契数列, 第30项的答案都算不出来 ",
		 		   		" 还不如for循环来的直接, 值得注意的是, 不是计算出了问题, 而是函数调用 ",
					],
	"关于对象的拷贝" : [
		 		   " 浅拷贝 ",
		 		   		" 将obj1进行 for...in 遍历 ",
		 		   		" 将obj1对应的所有键值都赋值给另外一个对象 ",
		 		   " 深拷贝 ",
		 		   		" 将obj1进行 for...in 遍历 ",
		 		   		" 如果出现数组, 那么判断当前的键值是否由数组对象创建 ",
		 		   			" 是的话要先让当的另外一个对象的键, 保存一个空数组 ",
		 		   			" 然后再次调用该函数, 也就是递归 ",
		 		   		" 如果出现对象, 那么判断当前的键值是否由object对象创建 ",
		 		   			" 是的话要先让当的另外一个对象的键, 保存一个空对象 ",
		 		   			" 然后再次调用该函数, 也就是递归 ",
		 		   		" 如果是正常情况, 将obj1对应的所有键值都赋值给另外一个对象 ",
		 		   " 注意点: 不能先判断对象, 因为万物皆对象 ",
					]
}