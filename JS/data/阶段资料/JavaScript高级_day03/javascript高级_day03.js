

var javascript高级_day03 = {
	"贪吃蛇案例2" : [
		 		   "1.0 创建蛇对象",
		 		   		" 创建自调用函数, 理清楚基本结构, 构造函数和原型",
		 		   		" 接收参数, 设置默认的宽高和方向, 设置body为一个默认长度的数组",
		 		   		" 数组中存储三个对象, 存放x和y的坐标及颜色",
		 		   		" 原型中, 设置初始化方法, 遍历body的数组长度 ",
		 		   		" 新建对应个数的盒子追加到页面中",
		 		   		" 将新建的盒子, push到一个数组中",
		 		   		" 获取对应的数据逐一设置到对应的盒子",
		 		   		" 拿到数组中的格数还需要乘以宽度和高度",
		 		   		" 暴露snake构造函数的名字",
		 		   		" 封装普通的remove函数",
		 		   			" 通过elements长度倒着遍历",
		 		   			" 在每一项的parentNode中, 调用removeChild方法, 删除elements[i]",
		 		   			" 在数组中, 调用splice方法, 从数组中第i个开始, 删除1个",
		 		   			" 每次调用render方法时, 要先执行一次remove方法",
		 		   "2.0 创建游戏对象",
		 		   		" 创建自调用函数, 通过构造函数存储实例化出来的Food对象和Snake对象",
		 		   		" 将map盒子通过传参接收起来 ",
		 		   		" 在原型start方法中调用Food和Snake的render方法 ",
		 		   		" 将父盒子通过this接收的属性传入参数 ",
		 		   		" 暴露Game构造函数的名字 ",
		 		   "3.0 封装蛇的move方法",
		 		   		" 通过Snake构造函数的原型扩展move方法 ",
		 		   		" 倒着循环body中的数组, 改变当前的格数等于上一个的格数",
		 		   		// this.body[i].x = this.body[i - 1].x;
		 		   		" 拿到头部的的对象",
		 		   		" 通过switch循环, 判断当前传入的direction, 根据情况加1还是减1",
		 		   "4.0 让蛇动起来",
		 		   		" 封装一个普通函数叫做runSnake",
		 		   			" 设置定时器每隔150毫秒执行一次",
		 		   			" 传入that替代Game的this, 调用this中snake实例的move方法",
		 		   			" 一定要调用对应的snake实例的render方法, 并且要传参",
		 		   			" 获取蛇移动横排和竖排最大的格数",
		 		   			" 通过that.snake.body[0].x获取蛇头当前的横排和竖排的格数",
		 		   			" 判断横排小于0或者大于等于最大格数, 就清除定时器并且弹出窗口",
		 		   			" 判断竖排小于0或者大于等于最大格数, 就清除定时器并且弹出窗口",
		 		   		" 封装一个普通函数叫做bindKey",
		 		   			" 给document对象绑定键盘按下事件, 传入事件对象",
		 		   			" 通过switch判断, 根据对应的keyCode编码判断改写that.snake.direction",
		 		   		" 在start方法中调用runSnake函数和bindKey函数",
		 		   "5.0 蛇吃食物",
		 		   		" 在snake的move方法中, 最后",
		 		   			" 获取head.x, head.y乘以this的宽度或者高度得到当前的位置",
		 		   			" 在Game的start方法中, 传入that.food实例, 在当前方法中接收参数",
		 		   			" 通过比较当前的head的x和y和food的x和y相等",
		 		   			" 则先保存body中最后一个的对象",
		 		   			" 向body中传入新的json, 属性为复制的last对应的值",
		 		   			" 调用food的render方法, 传入参数map",
		 		   			" 在函数口进行接收, 在调用口进行传参",
		 		   		" 获取父盒子, 实例游戏对象, 调用start方法, 传入参数"
					],
	"bind方法" : [
					"1.0 bind方法会改变this的指向, 并且返回一个新的函数",
					"2.0 案例中, 在每一个需要使用that的函数后面调用bind方法, 传入that参数 ",
						" 这样函数的内部就可以直接使用this了",
					" bind函数不能给有名字的函数后面直接使用 ",
						" 需要用函数名打点调用bind, 再用另外一个名字保存, 然后使用另外一个名字调用",
						" bind可以直接传一个对象, 可以让this指向该对象",
						" bind的参数可以传入多个值"
					],
	"自调用函数" : [
				   "js解析器不认识函数体直接加括号, 而增加其他标识符则可识别",
				   		"错误 ：function() { ... }() ",
				   		"正确 : (function() { ... })() / (function() { ... }())",
		 		   "奇葩用法 ",
				   		" +/-/!/~/ delete/typeof/new 1,/1+/1~ ",
				   		" 用new关键字的可以不加括号就调用 ",
		 		   "究竟用匿名函数, 或者叫自调用函数提不提倡? ",
				   		" 网上给出的说法是, 没有人反对 ",
				   		" 根据项目需求和可维护程度, 根据个人编程喜好 ",
				   	"自调用函数 重复声明会报错",
				   		"开头或者结尾写上分号, 或者只要是函数结束后都写一个分号",
				   		"一般大的框架, 都会给自执行函数的调用和function内部传参, (window, undefined)"
					],
	"对象之间的继承关系" : [
		 		   " 1.0 声明2个对象,  其中一个为空对象 ",
		 		   		" 设置对象的属性",
		 		   " 2.0 遍历该对象 ",
		 		   		" 通过遍历的键, 使用对象访问属性的方法, 赋值给空对象",
		 		   		" 封装实现过程, 提取参数 ",
		 		   		" 调用函数, 传入实际参数 ",
		 		   " 3.0 原型继承 ",
		 		   		" 目的: 实例1的构造函数A中未拥有某种方法, 不想创建, 想直接获取构造函数B中的方法",
		 		   		" 解决思路, 让构造函数A的原型等于构造函数B的实例",
		 		   			" 让构造函数A的构造器(constructor)指向自己",
		 		   		" 问题：构造函数A的实例需要多个, 但是构造函数B不能传参",
		 		   " 4.0 改变this的指向方法 -- call方法 ",
		 		   		" 在对象方法中, 调用函数的call方法, 也会改变函数的this指向, 并且会直接调用函数 ",
		 		   		" 而上面的bind的方法, 虽然也改变this指向, 但是会返回新的函数, 不会调用函数 ",
		 		   		" 此两种方法都可以通过多个参数进行传值 ",
		 		   " 5.0 借用构造函数和组合继承 ",
		 		   		" 在构造函数A中, 让构造函数B调用call方法, 并传入对象参数 ",
		 		   		" 但是只能继承构造函数中的属性, 而不能继承方法 ",
		 		   		" 组合继承 -- 解决不能继承原型方法的问题 ",
		 		   			" 在构造函数A中, 让构造函数B调用call方法, 并传入对象参数",
		 		   			" 将构造函数B中的原型赋值给构造函数A的原型 ",
		 		   			" 问题: 如果构造函数A增加了原型方法, 构造函数B的原型也被改动了 ",
		 		   			" 因为对象在赋值的时候, 如果只赋值名字, 那么操作的还是同一对象 ",
		 		   			" 解决, 构造函数A的原型等于构造函数B的实例 ",
		 		   			" 不过需要将构造器(constructor)指向自己 "
					]
}